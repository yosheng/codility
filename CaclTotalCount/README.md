给您n个积极整数的数组a。

考虑以下操作：从A中删除一个元素，并计算所有其余阵列元素的乘积。如果数组中只剩下一个元素，则产品等于该元素。

例如，如果a = [9，16，4]，我们可以：

删除9并获得等于（16×4）= 64的产品；

删除16并获得36的产品；

删除4并获得144的产品。

如上示例所示，产品可能会根据我们删除的元素而改变。

写一个函数：

类解决方案{public int解决方案（int [] a）;}

鉴于n个整数的数组a，可以返回可以通过从A中删除一个元素来获得的不同产品的数量。

示例：

1。给定a = [9，16，4]，该功能应返回3。如上所述，可实现的产品为64、36和144。

2。给定a = [3，4，2，3，1]，函数应返回4。

3。给定a = [1000000000，1000000000]，该功能应返回1。

为以下假设编写有效的算法：

n是[2..100,000]范围内的整数；

数组A的每个元素都是在[1..1,000,000,000]范围内的整数。